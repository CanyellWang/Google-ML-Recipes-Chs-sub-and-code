1
00:00:00,000 --> 00:00:00,000
Youtube subtitles download by mo.dbxdb.com 

2
00:00:00,000 --> 00:00:02,886
[MUSIC PLAYING]

3
00:00:02,886 --> 00:00:06,726


4
00:00:06,726 --> 00:00:08,100
只需要六行代码就可以

5
00:00:08,100 --> 00:00:10,130
写出你第一个机器学习的程序

6
00:00:10,130 --> 00:00:11,671
我是Josh
Gordon, 今天我将会

7
00:00:11,671 --> 00:00:14,374
带领你写出机器学习的Hello World

8
00:00:14,374 --> 00:00:16,039
在这系列视频的最初几集,

9
00:00:16,039 --> 00:00:17,998
我们会教你怎么从头开始

10
00:00:17,998 --> 00:00:19,079
学习机器学习

11
00:00:19,079 --> 00:00:21,560
首先，我们需要两个开源库,

12
00:00:21,560 --> 00:00:23,706
scikit-learn和TensorFlow.

13
00:00:23,706 --> 00:00:25,330
我们即将使用scikit库

14
00:00:25,330 --> 00:00:27,830
但首先，让我们大概说一下什么是机器学习

15
00:00:27,830 --> 00:00:29,240
以及它的重要性

16
00:00:29,240 --> 00:00:31,198
你可以把机器学习看作

17
00:00:31,198 --> 00:00:32,409
人工智能科学的一个分支

18
00:00:32,409 --> 00:00:35,610
早期的AI程序通常只擅长特定的事

19
00:00:35,610 --> 00:00:37,240
比如说“深蓝”能像顶级棋手一样

20
00:00:37,240 --> 00:00:40,150
下国际象棋，不过它也只会干这个

21
00:00:40,150 --> 00:00:41,780
现在我们想写出一个能解决许多不同问题的

22
00:00:41,780 --> 00:00:45,340
程序而不是对每个问题都写一个不同的程序

23
00:00:45,340 --> 00:00:47,460
AlphaGo是一个很好的例子

24
00:00:47,460 --> 00:00:50,150
这时候它正在世界围棋竞标赛上博弈学习

25
00:00:50,150 --> 00:00:53,740
但是类似的程序也能学会玩Atari游戏

26
00:00:53,740 --> 00:00:55,956
机器学习能把这一切变成可能

27
00:00:55,956 --> 00:00:57,330
它能从样本和经验中

28
00:00:57,330 --> 00:00:59,039
学习到算法

29
00:00:59,039 --> 00:01:00,909
而不是依赖于人为编写的规则

30
00:01:00,909 --> 00:01:02,200
所以这是十分先进的

31
00:01:02,200 --> 00:01:03,750
但是我们今天写的是

32
00:01:03,750 --> 00:01:05,632
一个非常简单的例子

33
00:01:05,632 --> 00:01:07,590
我会给你一个听起来很简单的问题

34
00:01:07,590 --> 00:01:09,662
但是不靠机器学习是解决不了的

35
00:01:09,662 --> 00:01:11,370
你能够写代码来分辨出

36
00:01:11,370 --> 00:01:12,774
苹果和橙子的不同之处吗？

37
00:01:12,774 --> 00:01:15,190
想象一下我叫你写一个程序，
以图像文件作为输入

38
00:01:15,190 --> 00:01:17,069
对其进行一些分析

39
00:01:17,069 --> 00:01:18,650
然后输出水果的类别

40
00:01:18,650 --> 00:01:20,040
你能解决这个问题吗？

41
00:01:20,040 --> 00:01:22,526
你得开始写很多特定的规则

42
00:01:22,526 --> 00:01:23,900
例如你可以编写代码来统计

43
00:01:23,900 --> 00:01:26,316
橙色像素的数量然后和绿色像素

44
00:01:26,316 --> 00:01:27,569
的数量作为比较

45
00:01:27,569 --> 00:01:30,920
这个比例能给你水果种类的提示

46
00:01:30,920 --> 00:01:33,043
这能应付像这种一样简单的图像

47
00:01:33,043 --> 00:01:34,709
但是当你深入研究这个问题

48
00:01:34,709 --> 00:01:37,099
你会发现这个世界是复杂的

49
00:01:37,099 --> 00:01:38,650
你编写的规则也不再适用

50
00:01:38,650 --> 00:01:41,180
你要怎么写代码处理黑白图片

51
00:01:41,180 --> 00:01:44,480
或者既没有苹果也没有橙子的图片？

52
00:01:44,480 --> 00:01:46,360
实际上对于你编写的任何规则

53
00:01:46,360 --> 00:01:48,790
我都能找到让它不适用的图像

54
00:01:48,790 --> 00:01:50,310
你需要编写成吨的规则,

55
00:01:50,310 --> 00:01:52,518
而这仅仅是为了辨别出苹果和橙子

56
00:01:52,518 --> 00:01:53,690
图像的不同之处

57
00:01:53,690 --> 00:01:57,390
如果我给你一个新的问题，你又得重新开始

58
00:01:57,390 --> 00:01:59,079
显然我们需要更好的方法

59
00:01:59,079 --> 00:02:00,760
因此我们需要一种算法

60
00:02:00,760 --> 00:02:02,480
能为我们找出其中的规则

61
00:02:02,480 --> 00:02:04,599
让我们不必要人工地写这些规则

62
00:02:04,599 --> 00:02:07,690
为此，我们来编写一个分类器

63
00:02:07,690 --> 00:02:10,360
现在你可以把一个分类器当作一个函数

64
00:02:10,360 --> 00:02:13,160
输入一些数据然后为其分配一个标签

65
00:02:13,160 --> 00:02:14,282
作为输出

66
00:02:14,282 --> 00:02:15,740
例如我有一张图片，想对它进行

67
00:02:15,740 --> 00:02:18,235
分类，判断这是苹果还是橙子

68
00:02:18,235 --> 00:02:20,110
又或者我有一封邮件想对其分类

69
00:02:20,110 --> 00:02:22,039
看是否为垃圾邮件

70
00:02:22,039 --> 00:02:23,690
这种自动写出分类器的技术

71
00:02:23,690 --> 00:02:26,220
被称为有监督学习(supervised learning)

72
00:02:26,220 --> 00:02:29,319
It begins with examples of
the problem you want to solve.

73
00:02:29,319 --> 00:02:31,620
为了用代码实现它，
我们将要使用scikit-learn库

74
00:02:31,620 --> 00:02:34,094
现在，我即将下载这个库

75
00:02:34,094 --> 00:02:35,970
有好几种方法去下载它

76
00:02:35,970 --> 00:02:38,241
但对我来说最简单的就是Anaconda.

77
00:02:38,241 --> 00:02:40,449
Anaconda十分方便的为我们安装完
所有依赖的组件

78
00:02:40,449 --> 00:02:42,440
而且还是跨平台的

79
00:02:42,440 --> 00:02:44,190
时间关系，下载和安装的部分

80
00:02:44,190 --> 00:02:45,776
被跳过了

81
00:02:45,776 --> 00:02:47,150
安装完后你可以测试一下

82
00:02:47,150 --> 00:02:48,608
看看是否能正常使用

83
00:02:48,608 --> 00:02:51,364
新建一个python脚本，然后载入SK learn库

84
00:02:51,364 --> 00:02:53,780
如果没有错误，那这就是我们的第一行代码

85
00:02:53,780 --> 00:02:56,145
还剩五行而已了

86
00:02:56,145 --> 00:02:57,520
对于有监督学习, 我们会遵循

87
00:02:57,520 --> 00:03:00,280
一些固定的步骤

88
00:03:00,280 --> 00:03:02,340
第一步是收集训练数据

89
00:03:02,340 --> 00:03:04,789
这是我们要解决的问题的一些样例

90
00:03:04,789 --> 00:03:06,789
我们的目标是编写一个函数

91
00:03:06,789 --> 00:03:08,002
对一些水果进行分类

92
00:03:08,002 --> 00:03:10,210
一开始输入一个水果的描述然后判断

93
00:03:10,210 --> 00:03:11,680
这是苹果还是橙子并输出所属类别

94
00:03:11,680 --> 00:03:14,349
判断的依据是水果的特征

95
00:03:14,349 --> 00:03:16,310
比如重量(Weight)和质感(Texture)

96
00:03:16,310 --> 00:03:18,160
为了收集我们的训练数据，

97
00:03:18,160 --> 00:03:19,310
想象我们去一个果园

98
00:03:19,310 --> 00:03:21,060
我们观察不同的苹果和橙子

99
00:03:21,060 --> 00:03:23,627
然后在表格中写下观察度量的结果描述

100
00:03:23,627 --> 00:03:25,210
在机器学习中，这些度量的结果

101
00:03:25,210 --> 00:03:26,650
被称为特征(Features)

102
00:03:26,650 --> 00:03:28,970
为了简化问题，在此我们仅使用两种特征：

103
00:03:28,970 --> 00:03:31,650
每个水果重多少克和水果的质地,

104
00:03:31,650 --> 00:03:33,830
比如说粗糙(bumpy)或光滑(smooth)

105
00:03:33,830 --> 00:03:35,860
一种好的特征能更容易地

106
00:03:35,860 --> 00:03:37,960
区分出水果种类的不同之处

107
00:03:37,960 --> 00:03:40,210
每一行训练数据都是一个样本数据

108
00:03:40,210 --> 00:03:42,259
每一个样本数据描述了一个水果

109
00:03:42,259 --> 00:03:44,240
最后一列数据是标签(label).

110
00:03:44,240 --> 00:03:46,257
其定义了每一行数据是哪一种水果

111
00:03:46,257 --> 00:03:47,840
这里只有两种可能：

112
00:03:47,840 --> 00:03:49,430
苹果和橙子

113
00:03:49,430 --> 00:03:51,560
这整个表格就是训练数据(training data)

114
00:03:51,560 --> 00:03:53,069
我们想分类器从这所有的样本数据

115
00:03:53,069 --> 00:03:55,120
中学习规则

116
00:03:55,120 --> 00:03:57,660
如果你拥有更多的数据，你就能

117
00:03:57,660 --> 00:03:59,310
创建更好的分类器

118
00:03:59,310 --> 00:04:01,620
现在让我们在代码里写下训练数据

119
00:04:01,620 --> 00:04:04,150
我们使用两个变量：
features 和 labels.

120
00:04:04,150 --> 00:04:06,060
Features包括头两列数据,

121
00:04:06,060 --> 00:04:07,887
labels包括最后一列数据.

122
00:04:07,887 --> 00:04:09,470
你可以把这当作以特征作为分类器的输入

123
00:04:09,470 --> 00:04:13,401
然后输出我们想要的标签

124
00:04:13,401 --> 00:04:15,650
我要把所有特征的数据类型由

125
00:04:15,650 --> 00:04:18,980
字符串(strings)改为整数(ints)
因此我用0代表粗糙(bumpy)，

126
00:04:18,980 --> 00:04:19,937
1代表光滑

127
00:04:19,937 --> 00:04:22,269
我还要对labels变量做同样的事：
用0代表苹果，

128
00:04:22,269 --> 00:04:23,740
1代表橙子

129
00:04:23,740 --> 00:04:26,300
这是我们程序的第二和第三行

130
00:04:26,300 --> 00:04:29,160
第二步就是使用这些样本来训练

131
00:04:29,160 --> 00:04:30,440
一个分类器

132
00:04:30,440 --> 00:04:32,350
我们的第一个分类器的类型是

133
00:04:32,350 --> 00:04:34,029
决策树（decision tree）

134
00:04:34,029 --> 00:04:35,449
我们以后会深入了解

135
00:04:35,449 --> 00:04:37,110
它是怎样工作的

136
00:04:37,110 --> 00:04:41,269
但是现在你可以把分类器当成
一个内置各种规则的黑盒子

137
00:04:41,269 --> 00:04:43,880
因为分类器有许多种

138
00:04:43,880 --> 00:04:47,740
但输入和输出基本都是相似的

139
00:04:47,740 --> 00:04:49,170
我现在就来载入决策树

140
00:04:49,170 --> 00:04:52,000
在脚本的第四行我们就创建了一个分类器

141
00:04:52,000 --> 00:04:54,459
这时候这个黑盒子里面还没有规则

142
00:04:54,459 --> 00:04:56,829
它还不知道苹果和橙子的任何信息

143
00:04:56,829 --> 00:04:58,870
为了训练它我们需要一个学习算法

144
00:04:58,870 --> 00:05:00,307
如果分类器是内置规则的黑盒子

145
00:05:00,307 --> 00:05:02,139
那你可以把学习算法当作

146
00:05:02,139 --> 00:05:04,170
通过在你的训练数据中寻找特定的模式

147
00:05:04,170 --> 00:05:06,937
来产生规则的程序

148
00:05:06,937 --> 00:05:09,269
例如，它会注意到橙子要更重一些

149
00:05:09,269 --> 00:05:11,920
所以它会建立一条规则：更重的水果

150
00:05:11,920 --> 00:05:14,269
更有可能是橙子

151
00:05:14,269 --> 00:05:16,130
在scikit库, 训练算法在

152
00:05:16,130 --> 00:05:19,315
分类器的类中，叫做Fit

153
00:05:19,315 --> 00:05:21,899
你可以认为Fit等同于

154
00:05:21,899 --> 00:05:23,136
“在数据中找模式”

155
00:05:23,136 --> 00:05:24,509
在以后我们会了解到

156
00:05:24,509 --> 00:05:27,040
这个算法工作的细节

157
00:05:27,040 --> 00:05:29,100
现在，我们有一个训练好的分类器

158
00:05:29,100 --> 00:05:32,860
让我们用它来分类一个新的水果样本

159
00:05:32,860 --> 00:05:36,036
输入分类器的是一个新样本的特征

160
00:05:36,036 --> 00:05:37,660
这表示我们想要进行分类的水果是

161
00:05:37,660 --> 00:05:39,750
150克和粗糙的

162
00:05:39,750 --> 00:05:43,870
输出0代表苹果，输出1代表橙子

163
00:05:43,870 --> 00:05:46,310
在我们按下回车查看分类结果之前

164
00:05:46,310 --> 00:05:47,690
让我们来想一想

165
00:05:47,690 --> 00:05:51,160
如果让你来猜，你认为会输出什么

166
00:05:51,160 --> 00:05:53,980
为了解决这个问题，我们来对比训练数据

167
00:05:53,980 --> 00:05:55,630
这看起来更像一个橙子

168
00:05:55,630 --> 00:05:57,076
因为它重而且粗糙

169
00:05:57,076 --> 00:05:59,160
这只是我的猜测，让我们按下回车

170
00:05:59,160 --> 00:06:01,834
发现我们的分类器分类结果是一样的

171
00:06:01,834 --> 00:06:03,250
如果你能完成这个程序，

172
00:06:03,250 --> 00:06:06,050
那这就是你第一个机器学习程序

173
00:06:06,050 --> 00:06:08,680
你可以为另外一种问题再建立一个分类器

174
00:06:08,680 --> 00:06:10,769
仅仅需要改变训练数据

175
00:06:10,769 --> 00:06:13,009
这使得这种方法比为了每个问题

176
00:06:13,009 --> 00:06:15,101
写一个新的规则更加可重复使用

177
00:06:15,101 --> 00:06:17,350
现在，你也许想知道为什么我们用

178
00:06:17,350 --> 00:06:19,790
一个表格而不是图像来描述水果

179
00:06:19,790 --> 00:06:21,759
并作为训练数据

180
00:06:21,759 --> 00:06:23,360
当然了，你可以使用图片，这个

181
00:06:23,360 --> 00:06:25,120
会在以后的视频中会学习到

182
00:06:25,120 --> 00:06:27,279
但是，你接下来会看到

183
00:06:27,279 --> 00:06:29,002
我们现在使用的方法更普遍

184
00:06:29,002 --> 00:06:30,959
你要明白的事情是

185
00:06:30,959 --> 00:06:32,028
写一个机器学习的程序并不难

186
00:06:32,028 --> 00:06:33,819
但是要让它正确地工作，你需要

187
00:06:33,819 --> 00:06:35,406
明白一些重要的概念

188
00:06:35,406 --> 00:06:37,990
接下来的几集视频我会跟你讲解这些

189
00:06:37,990 --> 00:06:40,197
非常感谢你的观看，我们很快会再见的

190
00:06:40,197 --> 00:06:43,850
[中文字幕：KnightJun 来源：Google Developers]
